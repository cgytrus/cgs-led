void(*reset)(void) = 0;

#include <EEPROM.h>
#include <FastLED.h>

const uint8_t PROGMEM gamma8[] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,
    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,
    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,
   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,
   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,
   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,
   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,
   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,
   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,
   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,
  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,
  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,
  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,
  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255 };

CRGB applyGamma(CRGB color) {
    color.r = pgm_read_byte(&gamma8[color.r]);
    color.g = pgm_read_byte(&gamma8[color.g]);
    color.b = pgm_read_byte(&gamma8[color.b]);
    return color;
}

#define PIN_RELAY 3

#define PIN_0 5
#define LED_COUNT_0 177
#define HALF_LED_COUNT_0 89
#define ENV_50_LED_COUNT_0 4
#define START_0 0
#define END_0 (START_0 + LED_COUNT_0 - 1)
#define HALF_START_0 0

#define PIN_1 6
#define LED_COUNT_1 82
#define HALF_LED_COUNT_1 41
#define ENV_50_LED_COUNT_1 2
#define START_1 (END_0 + 1)
#define END_1 (START_1 + LED_COUNT_1 - 1)
#define HALF_START_1 (HALF_START_0 + HALF_LED_COUNT_0)

#define PIN_2 9
#define LED_COUNT_2 30
#define START_2 (END_1 + 1)
#define END_2 (START_2 + LED_COUNT_2 - 1)
#define HALF_START_2 (HALF_START_1 + HALF_LED_COUNT_1)

#define TOTAL_LED_COUNT 289
#define TOTAL_DATA_COUNT (TOTAL_LED_COUNT * 3)
#define TOTAL_HALF_LED_COUNT 145
#define ONLY_ENV_50_LED_COUNT 50
#define ONLY_ENV_50_DATA_COUNT (ONLY_ENV_50_LED_COUNT * 3)
#define TOTAL_ENV_50_LED_COUNT (ONLY_ENV_50_LED_COUNT + LED_COUNT_2)
#define TOTAL_ENV_50_DATA_COUNT (TOTAL_ENV_50_LED_COUNT * 3)

const int ledStarts[] = { START_0, START_1, START_2 };
const int ledEnds[] = { END_0, END_1, END_2 };
const int ledCounts[] = { LED_COUNT_0, LED_COUNT_1, LED_COUNT_2 };

// modes
#define MODE_STANDBY 0
#define MODE_CUSTOM 1
#define MODE_TEST 2
#define MODE_FIRE 3
#define MODE_OFF 4

#define DEFAULT_BRIGHTNESS 63 // 0-255

#define CURRENT_EEPROM_VERSION 0
#define EEPROM_VERSION 0
#define EEPROM_BRIGHTNESS 1

#define BAUD_RATE 500000
#define DATA_TIMEOUT 7000 // ms

byte mode = MODE_OFF;
CRGB leds[TOTAL_LED_COUNT];

void resetSettings() {
    EEPROM.write(EEPROM_VERSION, CURRENT_EEPROM_VERSION);
    EEPROM.write(EEPROM_BRIGHTNESS, DEFAULT_BRIGHTNESS);
}

void loadSettings() {
    if(EEPROM.read(EEPROM_VERSION) != CURRENT_EEPROM_VERSION)
        resetSettings();
    FastLED.setBrightness(EEPROM.read(EEPROM_BRIGHTNESS));
}

void setup() {
    pinMode(PIN_RELAY, OUTPUT);
    digitalWrite(PIN_RELAY, LOW);

    Serial.begin(BAUD_RATE);

    FastLED.addLeds<WS2812B, PIN_0, GRB>(leds, 0, LED_COUNT_0);
    FastLED.addLeds<WS2812B, PIN_1, GRB>(leds, LED_COUNT_0, LED_COUNT_1);
    FastLED.addLeds<WS2812B, PIN_2, GRB>(leds, LED_COUNT_0 + LED_COUNT_1, LED_COUNT_2);

    loadSettings();

    FastLED.showColor(CRGB::Black);
}

#define DATA_NONE 0
#define DATA_RESET 1
#define DATA_SETTINGS_RESET 2
#define DATA_MODE 3
#define DATA_BRIGHTNESS 4
#define DATA_DIRECT_DATA 5
#define DATA_COMPRESSED_DIRECT_DATA 6
#define DATA_ENV_DIRECT_DATA 7
#define DATA_FFT_DATA 8
#define DATA_FFT_MIRRORED_DATA 9
#define DATA_PING 10

byte dataType = 0;
int allIndex = 0;
int ledIndex0 = 0;
int ledIndex1 = 0;
int ledIndex2 = 0;
byte tempCount = 0;
byte strip = 0;
bool compressionSwitch = false;
byte tempGreen = 0;
void endPacket() {
    dataType ^= dataType;
    allIndex ^= allIndex;
    ledIndex0 ^= ledIndex0;
    ledIndex1 ^= ledIndex1;
    ledIndex2 ^= ledIndex2;
    tempCount ^= tempCount;
    strip ^= strip;
    compressionSwitch ^= compressionSwitch;
    tempGreen ^= tempGreen;
}

unsigned long lastDataTime = 0;
void readSerial(byte data) {
    lastDataTime = millis();

    CRGB col;
    int dataCount;
    switch(dataType) {
        case DATA_NONE:
            dataType = data;
            break;
        case DATA_RESET:
            reset();
            endPacket();
            break;
        case DATA_SETTINGS_RESET:
            resetSettings();
            endPacket();
            break;
        case DATA_MODE:
            mode = data;
            if(mode != MODE_OFF)
                digitalWrite(PIN_RELAY, HIGH);
            if(!(mode ^ MODE_CUSTOM))
                Serial.write((byte)0);
            endPacket();
            break;
        case DATA_BRIGHTNESS:
            FastLED.setBrightness(data);
            EEPROM.write(EEPROM_BRIGHTNESS, data);
            endPacket();
            break;
        case DATA_DIRECT_DATA:
            leds[0].raw[allIndex] = pgm_read_byte(&gamma8[data]);
            if(++allIndex >= TOTAL_DATA_COUNT) {
                FastLED.show();
                Serial.write((byte)0);
                endPacket();
            }
            break;
        case DATA_COMPRESSED_DIRECT_DATA:
            if(!compressionSwitch) {
                //byte red = pgm_read_byte(&gamma8[((data & 0b11111000) >> 3) * 8]);
                byte red = data & 0b11111000;
                tempGreen = (data & 0b00000111) << 2;
                leds[0].raw[allIndex] = red;
            }
            else {
                //byte green = pgm_read_byte(&gamma8[((data & 0b11100000) >> 5) * 4 + tempGreen]);
                //byte blue = pgm_read_byte(&gamma8[(data & 0b00011111) * 8]);
                byte green = (data & 0b11100000) | tempGreen;
                byte blue = (data & 0b00011111) << 3;
                leds[0].raw[allIndex] = green;
                leds[0].raw[++allIndex] = blue;
            }
            compressionSwitch = !compressionSwitch;
            if(++allIndex >= TOTAL_DATA_COUNT) {
                FastLED.show();
                Serial.write((byte)0);
                endPacket();
            }
            break;
        case DATA_ENV_DIRECT_DATA:
            if(allIndex < ONLY_ENV_50_DATA_COUNT) {
                dataCount = LED_COUNT_0 * 3;
                for(int i = 0; i < ENV_50_LED_COUNT_0; i++)
                    if(ledIndex0 + i * 3 < dataCount)
                        leds[START_0 + i].raw[ledIndex0] = pgm_read_byte(&gamma8[data]);
                ++ledIndex0;

                dataCount = LED_COUNT_1 * 3;
                for(int i = 0; i < ENV_50_LED_COUNT_1; i++)
                    if(ledIndex1 + i * 3 < dataCount)
                        leds[START_1 + i].raw[ledIndex1] = pgm_read_byte(&gamma8[data]);
                ++ledIndex1;
            }
            else {
                leds[START_2].raw[allIndex - ONLY_ENV_50_DATA_COUNT] = pgm_read_byte(&gamma8[data]);
            }

            ++tempCount;
            if(tempCount >= 3) {
                tempCount ^= tempCount;
                ledIndex0 += ENV_50_LED_COUNT_0 * 3 - 3;
                ledIndex1 += ENV_50_LED_COUNT_1 * 3 - 3;
            }

            if(++allIndex >= TOTAL_ENV_50_DATA_COUNT) {
                FastLED.show();
                Serial.write((byte)0);
                endPacket();
            }
            break;
        case DATA_FFT_DATA:
            leds[allIndex].setHSV(data / 3, 255, data);
            //leds[allIndex] = applyGamma(leds[allIndex]);
            if(++allIndex >= TOTAL_LED_COUNT) {
                FastLED.show();
                Serial.write((byte)0);
                endPacket();
            }
            break;
        case DATA_FFT_MIRRORED_DATA:
            switch(allIndex) {
                case HALF_START_0:
                    strip = 0;
                    ledIndex0 ^= ledIndex0;
                    break;
                case HALF_START_1:
                    strip = 1;
                    ledIndex0 ^= ledIndex0;
                    break;
                case HALF_START_2:
                    strip = 2;
                    ledIndex0 ^= ledIndex0;
                    break;
            }

            col = leds[ledStarts[strip] + ledIndex0].setHSV(data / 3, 255, data);
            /*col = applyGamma(col);
            leds[ledStarts[strip] + ledIndex] = col;*/
            leds[ledEnds[strip] - ledIndex0] = col;
            ++ledIndex0;
            if(++allIndex >= TOTAL_HALF_LED_COUNT) {
                FastLED.show();
                Serial.write((byte)0);
                endPacket();
            }
            break;
        case DATA_PING:
            digitalWrite(PIN_RELAY, HIGH);
            endPacket();
            break;
    }
}

void drawModeStandby() {
    for(int i = 0; i < TOTAL_LED_COUNT; i++) {
        int offset = (int)(sin((double)(millis() + i * 100) / 1000.0) * 40.0);
        int sec = constrain(offset, 0, 255);
        leds[i].setRGB(sec, constrain(255 + offset, 0, 255), sec);
    }
}

void drawModeTest() {
    for(int i = 0; i < TOTAL_LED_COUNT; i++) {
        leds[i].setRGB(255, 255, 255);
    }
}

void drawModeFire() {
    unsigned long time = millis() / 10;
    fill_2dnoise8(leds, TOTAL_LED_COUNT, 1, false, 1, 0, 30, 0, 1, time, 1, 0, 1, 0, 1, 0, false);
}

void loop() {
    int data = Serial.read();
    if(~data)
        readSerial(data);

    switch(mode) {
        case MODE_CUSTOM:
            if((millis() - lastDataTime) >= DATA_TIMEOUT) {
                endPacket();
                mode = MODE_OFF;
                FastLED.showColor(CRGB::Black);
                digitalWrite(PIN_RELAY, LOW);
            }
            return;
        case MODE_STANDBY: drawModeStandby();
            break;
        case MODE_TEST: drawModeTest();
            break;
        case MODE_FIRE: drawModeFire();
            break;
    }

    if((millis() - lastDataTime) >= DATA_TIMEOUT) {
        mode = MODE_OFF;
        FastLED.showColor(CRGB::Black);
        digitalWrite(PIN_RELAY, LOW);
    }

    if(mode != MODE_OFF)
        FastLED.show();
}
